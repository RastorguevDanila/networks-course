# Практика 5. Прикладной уровень

## Программирование сокетов.

### A. Почта и SMTP (7 баллов)

### 1. Почтовый клиент (2 балла)
Напишите программу для отправки электронной почты получателю, адрес
которого задается параметром. Адрес отправителя может быть постоянным. Программа
должна поддерживать два формата сообщений: **txt** и **html**. Используйте готовые
библиотеки для работы с почтой, т.е. в этом задании **не** предполагается общение с smtp
сервером через сокеты напрямую.

Приложите скриншоты полученных сообщений (для обоих форматов).

#### Демонстрация работы
todo

### 2. SMTP-клиент (3 балла)
Разработайте простой почтовый клиент, который отправляет текстовые сообщения
электронной почты произвольному получателю. Программа должна соединиться с
почтовым сервером, используя протокол SMTP, и передать ему сообщение.
Не используйте встроенные методы для отправки почты, которые есть в большинстве
современных платформ. Вместо этого реализуйте свое решение на сокетах с передачей
сообщений почтовому серверу.

Сделайте скриншоты полученных сообщений.

#### Демонстрация работы
todo

### 3. SMTP-клиент: бинарные данные (2 балла)
Модифицируйте ваш SMTP-клиент из предыдущего задания так, чтобы теперь он мог
отправлять письма с изображениями (бинарными данными).

Сделайте скриншот, подтверждающий получение почтового сообщения с картинкой.

#### Демонстрация работы
todo

---

_Многие почтовые серверы используют ssl, что может вызвать трудности при работе с ними из
ваших приложений. Можете использовать для тестов smtp сервер СПбГУ: mail.spbu.ru, 25_

### Б. Удаленный запуск команд (3 балла)
Напишите программу для запуска команд (или приложений) на удаленном хосте с помощью TCP сокетов.

Например, вы можете с клиента дать команду серверу запустить приложение Калькулятор или
Paint (на стороне сервера). Или запустить консольное приложение/утилиту с указанными
параметрами. Однако запущенное приложение **должно** выводить какую-либо информацию на
консоль или передавать свой статус после запуска, который должен быть отправлен обратно
клиенту. Продемонстрируйте работу вашей программы, приложив скриншот.

Например, удаленно запускается команда `ping yandex.ru`. Результат этой команды (запущенной на
сервере) отправляется обратно клиенту.

#### Демонстрация работы
todo

### В. Широковещательная рассылка через UDP (2 балла)
Реализуйте сервер (веб-службу) и клиента с использованием интерфейса Socket API, которая:
- работает по протоколу UDP
- каждую секунду рассылает широковещательно всем клиентам свое текущее время
- клиент службы выводит на консоль сообщаемое ему время

#### Демонстрация работы
todo

## Задачи

### Задача 1 (2 балла)
Рассмотрим короткую, $10$-метровую линию связи, по которой отправитель может передавать
данные со скоростью $150$ бит/с в обоих направлениях. Предположим, что пакеты, содержащие
данные, имеют размер $100000$ бит, а пакеты, содержащие только управляющую информацию
(например, флаг подтверждения или информацию рукопожатия) – $200$ бит. Предположим, что у
нас $10$ параллельных соединений, и каждому предоставлено $1/10$ полосы пропускания канала
связи. Также допустим, что используется протокол HTTP, и предположим, что каждый
загруженный объект имеет размер $100$ Кбит, и что исходный объект содержит $10$ ссылок на другие
объекты того же отправителя. Будем считать, что скорость распространения сигнала равна
скорости света ($300 \cdot 10^6$ м/с).
1. Вычислите общее время, необходимое для получения всех объектов при параллельных
непостоянных HTTP-соединениях
2. Вычислите общее время для постоянных HTTP-соединений. Ожидается ли существенное
преимущество по сравнению со случаем непостоянного соединения?

#### Решение
Сразу заметим, что RTT пренебрежительно мало, а именно 2*1/(300*10^6) с.
Пропускная способность на 1 соединение = 150/10 = 15 бит/с
Для построения TCP-соединения для 1 объекта и загрузки этого объекта нам понадобятся 3 рукопожатия, 1 пакет для HTTP GET и пакет для самого объекта. Размеры управляющих пакетов - 200 бит, объекта - 100000 бит. Итого получается 200*4/15 + 100000/15 = 6720 сек.
Для загрузки по существующему TCP-соединению понадобится на 3*200/15=40 с. меньше, т.к. не понадобится учитывать рукопожатия (соединения уже созданы), это 6680 сек.
1. Для параллельных непостоянных. Нам потребуется создать 1 TCP-соединеие на запрос и получение базового html, это 6720 с. Теперь клиент видит 10 ссылок, на каждую надо установить TCP-соединение и потратить ещё столько же, но делаем мы это параллельно, а значит длительность равна длительности самого долгого, то есть любого, то есть 6720.
Итого 13440 с.
2. 1 TCP-соединение создать также придётся, а после один объект можно передать по уже созданному, но остальные 9 создать всё равно придётся, а при параллельном соединении время всё ещё определяется как длительность самого долгого из них, то есть любого из оставшихся 9, те же 6720. Ответ - те же 13440.
Разницы вообще нет. Единственное на чём можно сэкономить - это потенциальная непередача 3 рукопожатий. Но поскольку постоянность может использовать только 1 поток из 10, каждому из остальных 9 поток создать придётся, а значит никакой экономии и нет. 

### Задача 2 (3 балла)
Рассмотрим раздачу файла размером $F = 15$ Гбит $N$ пирам. Сервер имеет скорость отдачи $u_s = 30$
Мбит/с, а каждый узел имеет скорость загрузки $d_i = 2$ Мбит/с и скорость отдачи $u$. Для $N = 10$, $100$
и $1000$ и для $u = 300$ Кбит/с, $700$ Кбит/с и $2$ Мбит/с подготовьте график минимального времени
раздачи для всех сочетаний $N$ и $u$ для вариантов клиент-серверной и одноранговой раздачи.

#### Решение
Для клиент-серверной раздачи время определяется как max(NF/u_s, F/d_i). Она не зависит от u, поэтому распишем её для N=10,100,1000
F/u_s = 15000/30 = 500 с. 
F/d_i = 15000/2 = 7500 с.
10*F/u_s = 5000 с. ответ - 7500 с.
100*F/u_s = 50000 с. ответ - 50000 с.
1000*F/u_s = 500000 с. ответ - 500000 с.

Для одноранговой раздачи время определяется как max(F/u_s, F/d_i, NF/(u_s+Nu)) = max(7500, N*15000/(30+Nu)). 
u = 0.3: 
N=10: 7500
N=100: 25000
N=1000: 45455
u=0.7
N=10: 7500
N=100: 15000
N=1000: 20548
u=2 - все значения равны 7500.
График приложен отдельным файлом plot.png

### Задача 3 (3 балла)
Рассмотрим клиент-серверную раздачу файла размером $F$ бит $N$ пирам, при которой сервер
способен отдавать одновременно данные множеству пиров – каждому с различной скоростью,
но общая скорость отдачи при этом не превышает значения $u_s$. Схема раздачи непрерывная.
1. Предположим, что $\dfrac{u_s}{N} \le d_{min}$.
   При какой схеме общее время раздачи будет составлять $\dfrac{N F}{u_s}$?
2. Предположим, что $\dfrac{u_s}{N} \ge d_{min}$. 
   При какой схеме общее время раздачи будет составлять  $\dfrac{F}{d_{min}}$?
3. Докажите, что минимальное время раздачи описывается формулой $\max\left(\dfrac{N F}{u_s}, \dfrac{F}{d_{min}}\right)$?

#### Решение
1. Сервер должен одновременно передавать данные всем N пирам, выделяя каждому из них u_s/N (<=d_min, поэтому моэем позволить). Все пиры начнут и закончат загрузку одновременно, ровно через NF/u_s.
2. Обеспечим всем передачу d_min. Пропускной способности хватит, поскольку u_s>N*d_min по условию. Каждый пир завершит загрузку не позже, чем через F/d_min, а поскольку d_min определяется как наименьшая скорость из всех пиров, быстрее сделать не получится. Получим ровно F/d_min.
3. Сервер должен передать NF бит, максимальная скорость - u_s, он потратит не менее NF/u_s времени. С другой стороны, самый медленный пир должен загрузить F бит данных, его скорость загрузки не больше d_min. Значит на это потребуется F/d_min. Итого мы получили ограничение, что время ограничено снизу максимумом из этих величин - оценка доказана. Для построения примера сравним u_s/N и d_min и в зависимости от знака построим либо пример из пункта 1, либо 2.
